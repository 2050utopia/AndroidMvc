{"name":"Android Mvc Framework","tagline":"Android, MVC, MVVM, Unit Test, EventBus","body":"# AndroidMvc Framework\r\n## Features\r\n  - Easy to apply MVC/MVVM pattern for Android development\r\n  - Event driven\r\n  - Easy testing for controllers on JVM without Android dependency\r\n  - Dependency injection to make mock easy\r\n  - Manage navigation by NavigationController which is also testable\r\n  - Improved Fragment life cycles - e.g. Differentiate why view is created: 1. __NewlyCreated__, 2. __Rotated__ or 3. __StateRestored__\r\n  - Automatically save restore instance state\r\n\r\n\r\n## Overview\r\nUnlike iOS development, Android doesn't come with design pattern out of box and the SDK doesn't enforce any design pattern too. To apply design pattern to Android development is not straight forward due to the hard coupling of Android objects to all Android components. This hurdle not just makes coding less well organized but also harder unit testable.\r\n\r\nAndroidMvc provides a framework let Android development adopt MVC pattern much easier. With AndroidMvc framework, business logic can be easily abstracted out from Activity/Fragment/Service to pure java controllers not depending on any Android components which makes the controllers completely unit testable.\r\n![alt Android-Mvc-Pattern](https://github.com/kejunxia/AndroidMvc/blob/master/documents/imgs/Android-Mvc-Pattern.jpg?raw=true)\r\n\r\nAndroidMvc is event driven. Communication between controllers and views are linked by **EventBus**. To isolate events between different layers, there are 3 event buses pre-setup in the framework:\r\n\r\n- **EventBusC2V** (Controllers to Views): One way event bus routing events from controllers to views. Events sent to views will be guaranteed to be run on Android UI thread by the framework.\r\n- **EventBusC2C** (Controllers to Controllers): Routes events among controllers. Events will be received on the same thread who send them.\r\n- **EventBusV2V** (Views to views): Routes events among views. Events will be received on the same thread who send them.\r\n\r\n#### View\r\nAll views should be **as lean as possible** that they are only responsible to capture user interactions and display the data sent back from controllers via **EventBusC2V**. Therefore, business logic can be maximally abstracted away from views into controllers. As a result, more unit testings can be done upon controllers. At a high level, any components of Android framework could be considered as views including activities, fragments, widgets or even services and etc, because responsibilities of all components above are just to capture user interactions and present data to users.\r\n\r\n#### Controller\r\nControllers manage business logic including how to retrieve data, calculate, format data and wrap the data into event sending back to views. Controllers are defined in Interfaces and injected into views via @Inject annotation. In this way, the controllers would be easy to mocked against the interface definition. Views subscribed to events from controllers. When views receive user interactions, they invoke methods of injected controllers. The underlining controller implementations will process the request according to the business logic and send processed data back to views by events through **EventBusC2V**.\r\n\r\nNote that, in this MVC design, all controllers are **SINGLETON** application wide.\r\n\r\n#### Model\r\nModels in AndroidMVC design represent the state of controllers. So each controller has at only one model object to represent the state of the controller. The framework will automatically save and restore the instance state of the controller models. So we don't need to always manually write boiler plate code to saveInstanceState and restore them.\r\n\r\n#### Events\r\nViews should be updated by events sent from controllers. When methods of controllers get invoked by views, data will be loaded and updated in controllers followed by wrapping the updated data into events sending back to views. Therefore, the events can also be seen as **ViewModel** to update entire or partial view. In this way, the testing against views could be little because all data bound to views are formatted in the event by controllers. And the logic should be tested can be moved to controller unit tests which decouples the tests from Android SDK and can be run on JVM. Hence, the pattern could be considered as **MVVM** as well.\r\n\r\n\r\n## Download\r\nThe library is currently release to jCenter and MavenCentral\r\n\r\nGradle dependency is \r\n```groovy\r\ncompile \"com.shipdream:android-mvc:1.0\"\r\n```\r\n\r\n## Using AndroidMvc\r\n\r\nLet's take a simple app counting number as an example. The counter app has two navigation locations: \r\n1. LocationA: presented by FragmentA\r\n   * One text view to display the current count in number. Updated by event OnCounterUpdated\r\n   * Two buttons which increment and decrement count **on click**.\r\n   * An nested fragment with a TextView to display count in English. Updated by event OnCounterUpdated too\r\n   * An button to show advance view which results in navigating to LocationB\r\n   * Shares the result of counting updated by LocationB\r\n2. LocationB: presented by FragmentB\r\n   * One text view to display the current count in number. Updated by event OnCounterUpdated\r\n   * Two buttons which increment and decrement count **continuously on hold**.\r\n   * Shares the result of counting updated by LocationB\r\n\r\nBelow is how to use AndroidMvc framework to implement and test the app including navigation. Note the code below doesn't show all code. To see more details check the sample project in the app - Simple under samples subfolder.\r\n\r\n##### 1. Extend MvcActivity for the single Activity\r\n````java\r\n/**\r\n * Single activity for the app\r\n */\r\npublic class MainActivity extends MvcActivity {\r\n    /**\r\n     * Define how to map navigation location id to full screen fragments\r\n     * @param locationId The location id in string\r\n     * @return The class of the fragment representing the navigation locations\r\n     */\r\n    @Override\r\n    protected Class<? extends MvcFragment> mapNavigationFragment(String locationId) {\r\n        switch (locationId) {\r\n            case \"LocationA\":\r\n                return FragmentA.class;\r\n            case \"LocationB\":\r\n                return FragmentB.class;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the delegate fragment for the activity\r\n     * @return\r\n     */\r\n    @Override\r\n    protected Class<? extends DelegateFragment> getDelegateFragmentClass() {\r\n        return ContainerFragment.class;\r\n    }\r\n\r\n    /**\r\n     * Container fragment extends DelegateFragment would be the root container fragments to swap\r\n     * full screen fragments inside it on navigation.\r\n     */\r\n    public static class ContainerFragment extends DelegateFragment {\r\n        /**\r\n         * What to do when app starts for the first time\r\n         */\r\n        @Override\r\n        protected void onStartUp() {\r\n            //Navigate to location a when app starts for the first time by navigation controller\r\n            //here we navigate to LocationA which result in load FragmentA mapped by the\r\n            //the method mapNavigationFragment above\r\n            getNavigationController().navigateTo(this, \"LocationA\");\r\n        }\r\n    }\r\n}\r\n````\r\n##### 2. Create FragmentA to present \"LocationA\"\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n    /**\r\n     * @return Layout id used to inflate the view of this MvcFragment.\r\n     */\r\n    @Override\r\n    protected int getLayoutResId() {\r\n        return R.layout.fragment_a;\r\n    }\r\n}\r\n````\r\n##### 3. Create a controller contract and the model it's managing\r\n````java\r\npackage com.shipdream.lib.android.mvc.samples.simple.controller;\r\n\r\n/**\r\n * Define controller contract and its events. And specify which model it manages by binding the \r\n * model type.\r\n */\r\npublic interface CounterController extends BaseController<CounterModel> {\r\n    /**\r\n     * Increment count and will raise {@link EventC2V.OnCounterUpdated}\r\n     * @param sender Who requests this action\r\n     */\r\n    void increment(Object sender);\r\n\r\n    /**\r\n     * Decrement count and will raise {@link EventC2V.OnCounterUpdated}\r\n     * @param sender Who requests this action\r\n     */\r\n    void decrement(Object sender);\r\n\r\n    /**\r\n     * Method to convert number to english\r\n     * @param number\r\n     * @return\r\n     */\r\n    String convertNumberToEnglish(int number);\r\n\r\n    /**\r\n     * Namespace the events for this controller by nested interface so that all its events would\r\n     * be referenced as CounterController.EventC2V.BlaBlaEvent\r\n     */\r\n    interface EventC2V {\r\n        /**\r\n         * Event to notify views counter has been updated\r\n         */\r\n        class OnCounterUpdated extends BaseEventC2V {\r\n            private final int count;\r\n            private final String countInEnglish;\r\n            public OnCounterUpdated(Object sender, int count, String countInEnglish) {\r\n                super(sender);\r\n                this.count = count;\r\n                this.countInEnglish = countInEnglish;\r\n            }\r\n\r\n            public int getCount() {\r\n                return count;\r\n            }\r\n\r\n            public String getCountInEnglish() {\r\n                return countInEnglish;\r\n            }\r\n        }\r\n    }\r\n}\r\n````\r\n##### 3. Implement the controller\r\n**Note that, to allow AndroidMvc to find the default implementation of injectable object, the implementation class must be under the sub-package \"internal\" which resides in the same parent package as the interface and the name must be [InterfaceName]Impl.** For this example, say CounterController is under package samples.simple.controller the  implementation must be named as CounterControllerImpl and placed under package samples.simple.controller.internal\r\n````java\r\n/**\r\n * Note the structure of the package name. It is in a subpackage(internal) sharing the same parent \r\n * package as the controller interface CounterController\r\n */\r\npackage com.shipdream.lib.android.mvc.samples.simple.controller.internal;\r\n\r\n/**\r\n * Note the class name is [CounterController]Impl.\r\n */\r\npublic class CounterControllerImpl extends BaseControllerImpl<CounterModel> implements CounterController{\r\n    /**\r\n     * Just return the class type of the model managed by this controller\r\n     * @return\r\n     */\r\n    @Override\r\n    protected Class<CounterModel> getModelClassType() {\r\n        return CounterModel.class;\r\n    }\r\n\r\n    @Override\r\n    public void increment(Object sender) {\r\n        int count = getModel().getCount();\r\n        getModel().setCount(++count);\r\n        //Post controller to view event to views\r\n        postC2VEvent(new EventC2V.OnCounterUpdated(sender, count, convertNumberToEnglish(count)));\r\n    }\r\n\r\n    @Override\r\n    public void decrement(Object sender) {\r\n        int count = getModel().getCount();\r\n        getModel().setCount(--count);\r\n        //Post controller to view event to views\r\n        postC2VEvent(new EventC2V.OnCounterUpdated(sender, count, convertNumberToEnglish(count)));\r\n    }\r\n\r\n    @Override\r\n    public String convertNumberToEnglish(int number) {\r\n        if (number < -3) {\r\n            return \"Less than negative three\";\r\n        } else  if (number == -3) {\r\n            return \"Negative three\";\r\n        } else  if (number == -2) {\r\n            return \"Negative two\";\r\n        } else  if (number == -1) {\r\n            return \"Negative one\";\r\n        } else if (number == 0) {\r\n            return \"Zero\";\r\n        } else if (number == 1) {\r\n            return \"One\";\r\n        } else if (number == 2) {\r\n            return \"Two\";\r\n        } else if (number == 3) {\r\n            return \"Three\";\r\n        } else {\r\n            return \"Greater than three\";\r\n        }\r\n    }\r\n}\r\n````\r\n\r\n##### 4. Inject Controller into Views, setup views and handle C2V events from controllers\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n\t@Inject\r\n    private CounterController counterController;\r\n\r\n    private TextView display;\r\n    private Button increment;\r\n    private Button decrement;\r\n\r\n    /**\r\n     * @return Layout id used to inflate the view of this MvcFragment.\r\n     */\r\n    @Override\r\n    protected int getLayoutResId() {\r\n        return R.layout.fragment_a;\r\n    }\r\n\r\n    /**\r\n     * Lifecycle similar to onViewCreated by with more granular control with an extra argument to \r\n     * indicate why this view is created: 1. first time created, or 2. rotated or 3. restored\r\n     * @param view The root view of the fragment\r\n     * @param savedInstanceState The savedInstanceState when the fragment is being recreated after\r\n     *                           its enclosing activity is killed by OS, otherwise null including on\r\n     *                           rotation\r\n     * @param reason Indicates the {@link Reason} why the onViewReady is called.\r\n     */\r\n    @Override\r\n    public void onViewReady(View view, Bundle savedInstanceState, Reason reason) {\r\n        super.onViewReady(view, savedInstanceState, reason);\r\n\r\n        display = (TextView) view.findViewById(R.id.fragment_a_counterDisplay);\r\n        increment = (Button) view.findViewById(R.id.fragment_a_buttonIncrement);\r\n        decrement = (Button) view.findViewById(R.id.fragment_a_buttonDecrement);\r\n\r\n        increment.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                counterController.increment(v);\r\n            }\r\n        });\r\n\r\n        decrement.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                counterController.decrement(v);\r\n            }\r\n        });\r\n        \r\n        updateCountDisplay(counterController.getModel().getCount());\r\n    }\r\n\r\n    /**\r\n     * Callback when the fragment is popped out by back navigation\r\n     */\r\n    @Override\r\n    protected void onPoppedOutToFront() {\r\n        super.onPoppedOutToFront();\r\n        updateCountDisplay(counterController.getModel().getCount());\r\n    }\r\n\r\n    //Define event handler by method named as onEvent with single parameter of the event type\r\n    //to respond event CounterController.EventC2V.OnCounterUpdated\r\n    private void onEvent(CounterController.EventC2V.OnCounterUpdated event) {\r\n        updateCountDisplay(event.getCount());\r\n    }\r\n\r\n    /**\r\n     * Update the text view of count number\r\n     * @param count The number of count\r\n     */\r\n    private void updateCountDisplay(int count) {\r\n        display.setText(String.valueOf(count));\r\n    }\r\n}\r\n````\r\n##### 5. Unit tests on controllers\r\nAs discussed before, business logic should be decoupled from view(Android components) and abstracted to controllers, then we can pretty much test most logic just on controllers without dependencies of any Android components. Views just need to make sure data carried back from controllers are displayed correctly. Whether or not the data is processed correctly is completely controllers' responsibilities that is what is being tested here.\r\n\r\n````java\r\npublic class TestCounterController {\r\n\t...other dependencies are omitted here\r\n    \r\n    private CounterController counterController;\r\n\r\n    @Before\r\n    public void setUp() throws Exception {\r\n    \t...other dependencies are omitted here\r\n        \r\n        //create instance of CounterController\r\n        counterController = new CounterControllerImpl();\r\n        counterController.init();\r\n    }\r\n\r\n    @Test\r\n    public void increment_should_post_counter_update_event_with_incremented_value() {\r\n        //1. Prepare\r\n        //prepare event monitor\r\n        class Monitor {\r\n            void onEvent(CounterController.EventC2V.OnCounterUpdated event) {\r\n            }\r\n        }\r\n        Monitor monitor = mock(Monitor.class);\r\n        eventBusC2V.register(monitor);\r\n\r\n        //mock controller model for count value\r\n        int value = new Random().nextInt();\r\n        CounterModel counterModel = mock(CounterModel.class);\r\n        when(counterModel.getCount()).thenReturn(value);\r\n        //Bind the mock model to the controller\r\n        counterController.bindModel(this, counterModel);\r\n\r\n        //2. Act\r\n        counterController.increment(this);\r\n\r\n        //3. Verify\r\n        ArgumentCaptor<CounterController.EventC2V.OnCounterUpdated> updateEvent\r\n                = ArgumentCaptor.forClass(CounterController.EventC2V.OnCounterUpdated.class);\r\n        //event should be fired once\r\n        verify(monitor, times(1)).onEvent(updateEvent.capture());\r\n        //event should carry incremented value\r\n        Assert.assertEquals(value + 1, updateEvent.getValue().getCount());\r\n    }\r\n}\r\n````\r\n##### 5. Navigation\r\nInstead creating, replacing or popping full screen fragments by FragmentManager of Android Activity, AndroidMvc provides NavigationController to manage navigation. Therefore, navigation logic can be abstracted out from View layer. To make navigation easier to be tested, we can inject NavigationController to CounterController and then test the model of NavigationController to verify if navigation location is changed as expected.\r\n##### 5.1. Add two methods to CounterController to wrap navigation logic\r\n````java\r\npublic interface CounterController extends BaseController<CounterModel> {\r\n\t... other methods\r\n    \r\n\t/**\r\n     * Navigate to LocationB by {@link NavigationController}to show advance view that can update\r\n     * count continuously by holding buttons.\r\n     * @param sender\r\n     */\r\n    void goToAdvancedView(Object sender);\r\n\r\n    /**\r\n     * Navigate back to LocationA by {@link NavigationController}to show basic view from LocationB\r\n     * @param sender\r\n     */\r\n    void goBackToBasicView(Object sender);\r\n    \r\n\t... other methods\r\n}\r\n````\r\n##### 5.2. Inject NavigationController to CounterControllerImpl and implement navigation methods\r\n````java\r\npublic class CounterControllerImpl extends BaseControllerImpl<CounterModel> implements CounterController{\r\n\t... other methods\r\n    \r\n    @Inject\r\n    NavigationController navigationController;\r\n\r\n    @Override\r\n    public void goToAdvancedView(Object sender) {\r\n        navigationController.navigateTo(sender, \"LocationB\");\r\n    }\r\n\r\n    @Override\r\n    public void goBackToBasicView(Object sender) {\r\n        navigationController.navigateBack(sender);\r\n    }\r\n    \r\n    ... other methods\r\n}\r\n````\r\n##### 5.3. Invoke CounterController methods wrapping navigation in views\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n\t...\r\n    \r\n    @Override\r\n    public void onViewReady(View view, Bundle savedInstanceState, Reason reason) {\r\n        super.onViewReady(view, savedInstanceState, reason);\r\n\t\t\r\n        ...\r\n        \r\n        buttonShowAdvancedView.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //Use counterController to manage navigation to make navigation testable\r\n                counterController.goToAdvancedView(v);\r\n                //Or we can use NavigationController directly though it's harder to unit test on\r\n                //controller level.\r\n                //example:\r\n                //navigationController.navigateTo(v, \"LocationB\");\r\n            }\r\n        });\r\n\t\t\r\n        ...\r\n    }\r\n    \r\n    ...\r\n}\r\n\r\npublic class FragmentB extends MvcFragment {\r\n\t...\r\n    \r\n    @Override\r\n    public boolean onBackButtonPressed() {\r\n        //Use counterController to manage navigation back make navigation testable\r\n        counterController.goBackToBasicView(this);\r\n        //Return true to not pass the back button pressed event to upper level handler.\r\n        return true;\r\n        //Or we can let the fragment manage back navigation back automatically where we don't\r\n        //override this method which will call NavigationController.navigateBack(Object sender)\r\n        //automatically\r\n    }\r\n    \r\n    ...\r\n}\r\n````\r\n##### 5.4. Able to test navigation on CounterController\r\n````java\r\n    @Test\r\n    public void should_navigate_to_locationB_when_go_to_advance_view_and_back_to_locationA_after_go_to_basic_view() {\r\n        //Prepare\r\n        NavigationController navigationController = ((CounterControllerImpl) counterController).navigationController;\r\n        NavigationController.Model navModel = navigationController.getModel();\r\n        //App has not navigated to anywhere, current location should be null\r\n        Assert.assertNull(navModel.getCurrentLocation());\r\n        //Simulate navigating to location A\r\n        navigationController.navigateTo(this, \"LocationA\");\r\n        //Verify: location should be changed to LocationA\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationA\");\r\n\r\n        //Act: CounterController now goes to advanced view underlining logic is navigating to locationB\r\n        counterController.goToAdvancedView(this);\r\n\r\n        //Verify: Current location should be LocationB\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationB\");\r\n\r\n        //Act: CounterController now goes back to basic view underlining logic is navigating back to locationA\r\n        counterController.goBackToBasicView(this);\r\n\r\n        //Verify: Current location should be back to LocationA\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationA\");\r\n    }\r\n````\r\n\r\n## Other features\r\n#### 1. Dependency Injection\r\n\r\n##### @Inject\r\n\r\nThe framework currently only support field injection. To inject an object, use @Inject to annotate fields and then inject the object with those fields by\r\n````java\r\nAndroidMvc.graph().inject(ObjectToBeInjected)\r\n````\r\nAll injected objects will be reference counted. This is because\r\nthe graph will automatically save and restore injected objects implementing StateManaged. For performance reasons the injected but not anymore referenced objects don't need to be saved and restored. So don't forget to call\r\n````java\r\nAndroidMvc.graph().release(ObjectBeenInjected)\r\n````\r\nto dereference them. Fortunately, all MvcFragment will do the injection and releasing in their\r\nAndroid lifecycle - onCreate and onDestroy. So we don't need to do this manually for fragments.\r\n\r\n##### @Provides\r\nTo provide the instance to inject the\r\nfields, there are 2 ways.\r\n\r\n1. **Name pattern**. The implementation of the injecting class will be located by file structure and\r\nfile name. A default implementation will be looked for in the sub folder - internal from the parent\r\nfolder of the interface and the name of the file should be [InterfaceName]Impl. For example, we\r\ndefine a controller LoginController in folder /controllers/LoginController then the implementation\r\nshould be placed under /controllers/internal and named as LoginControllerImpl. So the implementation\r\nshould be at /controllers/internal/LoginControllerImpl\r\n\r\n2. **Register providers** by extending a Component and annotate the methods providing the instance by\r\n**@Provides**. This can be used to replace the implementation located by the name pattern described\r\nabove for the unit testing. Also the component can be unregistered from **@Singleton** can\r\nbe used if singleton is required. Beware singleton is relative to the ScopeCache associated to the\r\nComponent. So to make the instance absolute singleton, either guarantee the Component is the unique\r\nor the ScopeCache associated to the Component is unique. In other words, if the component is\r\nrecreated or the cache of it is recreated it new instance will be provided and cached sharing the\r\nsame time span as the component or its cache again.\r\n\r\n\r\n### 2. Unit testing on asynchronous actions, e.g. Http requests\r\nBelow is an example to consume a public weather API from [OpenWeatherMap](http://openweathermap.org/api). To be able to test controller without real http communication, the http request can be abstracted into a service interface. The service interface is injected into controllers. Then in real implementation of the service interface we send http request by http client while in controller testings we mock the service to provide mock data. \r\n\r\nSee more details in the sample project - Node\r\n\r\n**Note that, BaseMvcControllerImpl provides protected methods to run actions asynchronously. The ExecutorService is injected into controllers. By default, AndroidMvc framework automatically injects with an implementation running tasks on non-main thread. Whereas in unit tests we can override the injection with an implementation runs the task on the same thread as the caller's so that the asynchronous actions can be tested easier.**\r\n````java\r\n/**\r\n * Run async task on the default ExecutorService injected as a field of this class. Exceptions\r\n * occur during running the task will be handled by the given {@link AsyncExceptionHandler}.\r\n *\r\n * @param sender                who initiated this task\r\n * @param asyncTask             task to execute\r\n * @param asyncExceptionHandler error handler for the exception during running the task\r\n * @return the reference of {@link AsyncTask} that can be used to query its state and cancel it.\r\n */\r\nprotected AsyncTask runAsyncTask(Object sender, AsyncTask asyncTask, AsyncExceptionHandler asyncExceptionHandler)\r\n````\r\n\r\n##### 1. Define http service interface\r\n````java\r\npackage com.shipdream.lib.android.mvc.samples.note.service.http;\r\n\r\npublic interface WeatherService {\r\n    /**\r\n     * Get weathers of the cities with the given ids\r\n     * @param ids Ids of the cities\r\n     * @return The response\r\n     */\r\n    WeatherListResponse getWeathers(List<Integer>ids) throws IOException;\r\n}\r\n````\r\n##### 2. Send and consume real http service in implementation\r\n````java\r\n/**\r\n * Note the package structure which is under internal subpackage sharing the same parent package as \r\n * WeatherService as above\r\n */\r\npackage com.shipdream.lib.android.mvc.samples.note.service.http.internal;\r\n\r\npublic class WeatherServiceImpl implements WeatherService{\r\n    private HttpClient httpClient;\r\n    private Gson gson;\r\n\r\n    public WeatherServiceImpl() {\r\n        httpClient = new DefaultHttpClient();\r\n        gson = new Gson();\r\n    }\r\n\r\n    @Override\r\n    public WeatherListResponse getWeathers(List<Integer> ids) throws IOException {\r\n        String idsStr = \"\";\r\n        for (Integer id : ids) {\r\n            if (!idsStr.isEmpty()) {\r\n                idsStr += \", \";\r\n            }\r\n            idsStr += String.valueOf(id);\r\n        }\r\n        String url = String.format(\"http://api.openweathermap.org/data/2.5/group?id=%s&units=metric\",\r\n                URLEncoder.encode(idsStr, \"UTF-8\"));\r\n        HttpGet get = new HttpGet(url);\r\n        HttpResponse resp = httpClient.execute(get);\r\n        String responseStr = EntityUtils.toString(resp.getEntity());\r\n        return gson.fromJson(responseStr, WeatherListResponse.class);\r\n    }\r\n}\r\n````\r\n##### 3. Inject the http service into WeatherControllerImpl\r\n````java\r\npublic class WeatherControllerImpl extends BaseControllerImpl <WeatherModel> implements\r\n        WeatherController{\r\n\t....\r\n    \r\n    @Inject\r\n    private WeatherService weatherService;\r\n    \r\n    //consume the service and fetch weathers\r\n    //...\r\n}\r\n````\r\n##### 4. In controller unit test, override injection of ExecutorService with implementation running actions on the same thread as the caller's\r\nCode below is partial implementation, see sample Note in the project for more details.\r\n````java\r\npublic class TestWeatherController extends TestControllerBase<WeatherController> {\r\n@Override\r\nprotected void registerDependencies(MvcGraph mvcGraph) {\r\n\t...\r\n    \r\n\t//Setup mock executor service mock that runs task on the same thread.\r\n\texecutorService = mock(ExecutorService.class);\r\n\tdoAnswer(new Answer() {\r\n\t\t@Override\r\n\t\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\r\n\t\t\tRunnable runnable = (Runnable) invocation.getArguments()[0];\r\n\t\t\trunnable.run();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}).when(executorService).submit(any(Runnable.class));\r\n\r\n    //Register the injecting component to mvcGraph to override the implementation being injected\r\n    //to controllers\r\n\tTestComp testComp = new TestComp();\r\n\ttestComp.testNoteController = this;\r\n\tmvcGraph.register(testComp);\r\n}\r\n}\r\n````\r\n\r\n##### 5. Test if WeatherController sends successful event with good http response\r\nWhat to mock\r\n1. Http Service to provide good response\r\n2. Event monitor to subscribe to the successful event\r\nSo when WeatherController#updateAllCities(Object) is called, we can verify whether the mocked monitor receives the successful event.\r\n\r\n````java\r\n@Test\r\npublic void shouldRaiseSuccessEventForGoodUpdateWeathers() throws IOException {\r\n\t//---Arrange---\r\n\t//Define a subscriber class\r\n\tclass Monitor {\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdated event) {\r\n\t\t}\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdateFailed event) {\r\n\t\t}\r\n\t}\r\n\tMonitor monitor = mock(Monitor.class);\r\n    //Subscribe to eventBus\r\n\teventBusC2V.register(monitor);\r\n\r\n    //Weather service mock prepares a good response\r\n\tWeatherListResponse responseMock = mock(WeatherListResponse.class);\r\n\twhen(weatherServiceMock.getWeathers(any(List.class))).thenReturn(responseMock);\r\n\r\n\t//---Action---\r\n\tcontrollerToTest.updateAllCities(this);\r\n\r\n\t//---Verify---\r\n\t//Success event should be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdated> eventSuccess\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdated.class);\r\n\tverify(monitor, times(1)).onEvent(eventSuccess.capture());\r\n\t//Failed event should not be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdateFailed> eventFailure\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdateFailed.class);\r\n\tverify(monitor, times(0)).onEvent(eventFailure.capture());\r\n}\r\n````\r\n\r\n##### 6. **Test if WeatherController sends failed event with bad http response**\r\nWhat to mock\r\n1. Http Service to provide bad response\r\n2. Event monitor to subscribe to the failed event\r\nSo when WeatherController#updateAllCities(Object) is called, we can verify whether the mocked monitor receives the failed event.\r\n````java\r\n@Test\r\npublic void shouldRaiseFailEventForNetworkErrorToUpdateWeathers() throws IOException {\r\n\t//---Arrange---\r\n\t//Define a subscriber class\r\n\tclass Monitor {\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdated event) {\r\n\t\t}\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdateFailed event) {\r\n\t\t}\r\n\t}\r\n\tMonitor monitor = mock(Monitor.class);\r\n    //Subscribe to eventBus\r\n\teventBusC2V.register(monitor);\r\n    \r\n\t//Weather service mock prepares a bad response \r\n    //by throwing an exception when getting the weather data\r\n\twhen(weatherServiceMock.getWeathers(any(List.class))).thenThrow(new IOException());\r\n\r\n\t//---Action---\r\n\tcontrollerToTest.updateAllCities(this);\r\n\r\n\t//---Verify---\r\n\t//Success event should not be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdated> eventSuccess\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdated.class);\r\n\tverify(monitor, times(0)).onEvent(eventSuccess.capture());\r\n\t//Failed event must be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdateFailed> eventFailure\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdateFailed.class);\r\n\tverify(monitor, times(1)).onEvent(eventFailure.capture());\r\n}\r\n````\r\n\r\n### 3. Custom mechanism to automatically save/restore models of controllers\r\nBy default, AndroidMvc uses GSON to serialize and deserialize models of controllers automatically. In general uses the performance is acceptable. For example, on rotation, as long as the models are not very large, the frozen time of the rotation would be between 200ms and 300ms.\r\n\r\nIf we need to provide more optimized mechanism to do so in case there are large models taking long to be serialized and deserialized by GSON, custom StateKeeper can be set to provide alternative save/restore implementation. For Android, Parcelable is the best performed mechanism to save/restore state but it is not fun and error prone. Fortunately, there a handy library [Parceler](https://github.com/johncarl81/parceler) from another developer does this automatically. In the example below, we tried this library to implement custom StateKeeper to save/restore state by Parcelables automatically. The best place to set the custom StateKeeper is the Application#onCreate(). \r\n\r\nCheck out more details in the sample code - Note\r\n\r\n````java\r\npublic class NoteApp extends Application {\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n\r\n        AndroidMvc.setCustomStateKeeper(new AndroidStateKeeper() {\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public Parcelable saveState(Object state, Class type) {\r\n                /**\r\n                 * Use parcelable to save all states.\r\n                 */\r\n                return Parcels.wrap(state);\r\n                //type of the state can be used as a filter to handle some state specially\r\n                //if (type == BlaBlaType) {\r\n                //    special logic to save state\r\n                //}\r\n            }\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public Object getState(Parcelable parceledState, Class type) {\r\n                /**\r\n                 * Use parcelable to restore all states.\r\n                 */\r\n                return Parcels.unwrap(parceledState);\r\n                \r\n                //type of the state can be used as a filter to handle some state specially\r\n                //if (type == BlaBlaType) {\r\n                //    special logic to restore state\r\n                //}\r\n            }\r\n        });\r\n    }\r\n}\r\n````\r\n\r\n## Download\r\nThe library is currently release to jCenter and MavenCentral\r\n\r\nGradle dependency is\r\n```groovy\r\ncompile \"com.shipdream:android-mvc:1.0\"\r\n```\r\n\r\n## Samples APKs\r\n - [Counter](https://github.com/kejunxia/AndroidMvc/blob/master/documents/apks/samples/simple-counter.apk) - A simple sample demonstrates how to use the framework including dependency injection, event bus, unit testing, navigation and etc.\r\n - [Note](https://github.com/kejunxia/AndroidMvc/blob/master/documents/apks/samples/notes.apk) - Another more complex sample also demonstrates how to use async tasks to get network resources and test the async task without Android SDK on pure JVM.\r\n","google":"UA-21820164-19","note":"Don't delete this file! It's used internally to help with page regeneration."}