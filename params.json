{"name":"Android Mvc Framework","tagline":"Android, Design Pattern, MVC, MVVM, Unit Test, EventBus, Android MVC Framework","body":"# AndroidMvc Framework\r\n## Introduction\r\nFirst of all, let's look at some problems of the Android development below:\r\n- **No enforced design pattern**. That's why there are many questions online asking about how to implement MVC, MVVM, MVP and etc patterns to Android.\r\n- **Hard to do unit testing** for Android since the tight coupling of Android components. For example most Android components are heavily depending on \"android.Content.Context\". Mocking Android components would lead to \"Error java.lang.RuntimeException: Stub!\".\r\n\r\n  Though there is a great Android test tool - Robolectric makes it much easier, it only shadows core parts of Android framework because there are too many components there. Another issue sometimes Android frameworks got some bugs and even worse only on specific versions of Android SDK or support library. In this case, pass of test with Roboletric doesn't necessarily guarantee the end to end behavior is correct. For an instance, this bug [Nested Fragment doesn't retain instance state as expected since support library v4.rev 20](https://code.google.com/p/android/issues/detail?id=74222) is a serious issue Android team has not targeted for ages. With this bug, if we got a view in a nested fragment, Roboletric may think we can see this view with specific logic. But this view may not show up on real devices.\r\n\r\n  Furthermore, if the purpose is to test controller or business logic we don't have to use real or even shadowed Android functions. For example, if we are developing a calculator and we can wrap core math functions in a calculator controller. To test the calculator controller, should the controller care about if the view is Android, a mock, HTML or even iOS? No, the controller itself doesn't need to have anything related to Android. We just want to test if we give 1+1 to the controller as input does it return 2. See the samples below or in the github code to see how AndroidMvc abstract Android components out from controllers.\r\n\r\n\r\n- **Flawed lifecycle of Activity/Fragment**. Take a news app as an example. Think about this scenario, when the app resumes from background and needs to call services to get latest content to refresh the page. Which lifecycle callback should the refresh logic sit in? onResume? OK, the page would be refreshed on each rotation as well which is definitely NOT what we want. This is just one example of many, you might have seen more conflicting scenarios with the lifecycle that we have to write dodgy code to work around.\r\n- **Tedious to manage app instance state**. App is likely to crash when relaunch an activity that has been killed by OS. This doesn't have to happen if all state the activity is referencing is carefully saved and restored. But it is painful as it requires a lot of boilerplate code in onSaveInstanceState and onCreate and still easy to break if anything is missing.\r\n- **Not easy to share state during navigation.** When navigate from one activity to another, if the app needs to share data the data has to be put into Bundle. If the data is not primitive, it needs to be serialised or parceled. Furthermore, this is not fun and mistake prone because it's all key-value pair based which loses the compile time strong type check.\r\n- **Large memory consumption with deep fragments back stack** Android doesn't call onDestroy of fragments if they are pushed into back stack and will hold the memory they used. If we have a deep fragment back stack, it will be a huge waste of memory and the worst to cause out of memory crash! So when a fragment is pushed into back stack, the instances of its holding members could be released as long as it's saved by onSaveInstanceState and restored properly when the fragment is resuming after popped out from the back stack.\r\n\r\n**AndroidMvc framework comes to tackle the problems above and provides more**\r\n\r\n##### AndroidMvc Features\r\n  - Easy to apply MVC/MVVM pattern for Android development\r\n  - Easy testing for controllers on JVM without Android dependency\r\n  - Automatically save restore instance state\r\n  - Improved Fragment lifecycle\r\n    - __onViewReady(View view, Bundle savedInstanceState, Reason reason):__ Where reason differentiates the cause of creation of view: 1. __FIRST_TIME__, 2. __ROTATE__, 3. __RESTORE__\r\n    - __onReturnForeground():__ When app resume from background\r\n    - __onOrientationChanged(int lastOrientation, int currentOrientation):__ When app rotated\r\n    - __onPushingToBackStack():__ When current page is pushed into back stack and navigate to next page\r\n    - __onPoppedOutToFront():__ When last page is becomes the top page on backwards navigation\r\n  - Manage navigation by NavigationController which is also testable\r\n  - Event driven views\r\n  - [Dependency injection to make mock easy](https://github.com/kejunxia/AndroidMvc/tree/master/library/poke)\r\n  - Optimized memory consumption. Since most data are abstracted out to models, fragments are much leaner. When fragments are pushed to back stack, AndroidMvc will release controllers the fragments hold. Therefore most of the memory used by the models of the controllers will be freed. When the fragments are popped out of the back stack, AndroidMvc will resume the models of their controllers automatically.\r\n  - Well tested by jUnit and instrument test with Espresso.\r\n\r\n## Download\r\nThe library is currently release to jCenter and MavenCentral\r\n\r\n**Maven:**\r\n```xml\r\n<dependency>\r\n    <groupId>com.shipdream</groupId>\r\n    <artifactId>android-mvc</artifactId>\r\n    <version>1.2.1</version>\r\n</dependency>\r\n```\r\n\r\n**Gradle:**\r\n```groovy\r\ncompile \"com.shipdream:android-mvc:1.2.1\"\r\n```\r\n\r\n## Samples\r\n - **[Counter](https://docs.google.com/uc?authuser=0&id=0BwcZml9gnwoZRS1pYURMMVRzdHM&export=download)** - A simple sample demonstrates how to use the framework including dependency injection, event bus, unit testing, navigation and etc.\r\n         \r\n   See [**Source code** here](https://github.com/kejunxia/AndroidMvc/tree/master/samples/simple) and download [**Sample APK** here](https://docs.google.com/uc?authuser=0&id=0BwcZml9gnwoZRS1pYURMMVRzdHM&export=download)\r\n   \r\n   \r\n - **[Note](https://docs.google.com/uc?authuser=0&id=0BwcZml9gnwoZOHcxZFI3Z0ZGUUk&export=download)** - A more complex sample to make notes and query weathers with slide menu and also demonstrates how consume network resources ([public weather API](http://openweathermap.org/api)) and test the async task without depending on Android SDK on pure JVM.\r\n\r\n   See [**Source code** here](https://github.com/kejunxia/AndroidMvc/tree/master/samples/note) and download [**Sample APK** here](https://docs.google.com/uc?authuser=0&id=0BwcZml9gnwoZOHcxZFI3Z0ZGUUk&export=download)\r\n\r\n## Overview\r\n![alt Android-Mvc-Pattern](https://github.com/kejunxia/AndroidMvc/blob/master/documents/imgs/Android-Mvc-Pattern.jpg?raw=true)\r\n\r\nAndroidMvc is event driven. To isolate events between different layers, there are 3 event buses pre-setup in the framework:\r\n\r\n- **EventBusC2V** (Controllers to Views): One way event bus routing events from controllers to views. Events sent to views will be guaranteed to be run on Android UI thread by the framework.\r\n- **EventBusC2C** (Controllers to Controllers): Routes events among controllers. Events will be received on the same thread who send them.\r\n- **EventBusV2V** (Views to views): Routes events among views. Events will be received on the same thread who send them.\r\n\r\n#### View\r\nAll views should be **as lean as possible** because their responsibilities are only to capture user interactions and display data. Then as long as controllers are unit tested properly it's less likely to make mistake on view layer. Therefore, business logic can be maximally abstracted away from views into controllers. As a result, more business logic can be unit tested against controllers directly.\r\n\r\nAt a high level, all components of Android framework could be considered as views including activities, fragments, widgets and even services and etc, because as mentioned above, responsibilities of all Android components are just to capture user interactions and present data to users.\r\n\r\nAn analogy is that we can think Android as a browser. HTML (<!doctype html>) is like an activity, iFrame or a Ajax driven div is like a fragment and a javascript timer running as a polling loop is like a Android service. So as we can see, like what a service oriented web app does, all business logic should not be put on the front end (html/css/javascript) but in controllers on backend such as servlet, php, nodejs, asp.net and etc.\r\n\r\n#### Controller\r\nControllers manage business logic including how to retrieve, calculate, format and wrap the data into event sending back to views. Controllers are defined in Java interfaces and injected into views via annotation @Inject. In this way, the controllers would be easy to mocked against the interface definition. Views subscribe to events defined by those controller interfaces. When views receive user interactions, they invoke methods against the injected controller interfaces. The underlining controller implementations will process the request by required business logic and send processed data back to views by events through **EventBusC2V** that views have subscribed on.\r\n\r\nNote that, in this MVC design, all controllers are **SINGLETON** application wide so that the state of controllers are guaranteed from the same source of truth.\r\n\r\n#### Model\r\nModels in AndroidMVC design encapsulate and represent the state of controllers. So each controller has only one model object to represent the state of the specific business logic. When the controllers are requested to process data, they will manage the model and box and format part of or entire model into an event subscribed by view and notify the views to update themselves by the data conveyed by the event. Alternatively, the views can also directly read the model from the controllers injected into them as long as their is no much formatting requirement. But make sure, views should NOT change the value of models directly which should be only done by controllers.\r\n\r\nIn addition, to reduce boiler plate code, AndroidMvc framework will automatically save and restore the instance state of the controller models. So we don't need to always manually write code manually to use saveInstanceState and restore them in onCreate.\r\n\r\n#### Events\r\nWith the builtin EventBus, events are defined as Java classes. It's also recommended to define them in controller interfaces to namespace them, so that we know what do the events do with more context. In addition, in a complex application with thousands of different events, the events won't be scattered everywhere. Events defined as Java classes instead of strings like Android messages has many benefits such as 1. extra data can be self-contained in them, 2. they are strong typed which avoids typo that can make debugging like a disaster, 3. strong typed events are also easier to track through inside IDEs (Android Studio, Eclipse and etc).\r\n\r\nOnce a event is defined, it can be broadcast to multiple views who subscribe to them. When events contain data, they can be thought as a partial **ViewModel** that will drive subscribed views to update themselves. So to some extent AndroidMvc could be thought as a variant of **MVVM** pattern as well.\r\n\r\nTo use it as a traditional **MVVM** or an Ajax like MVVM is totally depending on how the events are designed. For example, we can define only one event for a controller called EventC2V.OnModelUpdate and whenever the controller updates the model it raise this event. In this way, it's exactly the same as the traditional **MVVM** pattern. Also we can divide the update of model into more granular events, then it's like Ajax in web app and the earlier approach is like to refresh the whole page whenever there is a model update.\r\n\r\n\r\n## Using AndroidMvc\r\n\r\nLet's take a simple app counting number as an example. The counter app has two navigation locations:\r\n1. LocationA: presented by FragmentA\r\n   * One text view to display the current count in number. Updated by event OnCounterUpdated\r\n   * Two buttons which increment and decrement count **on click**.\r\n   * An nested fragment with a TextView to display count in English. Updated by event OnCounterUpdated too\r\n   * An button to show advance view which results in navigating to LocationB\r\n   * Shares the result of counting updated by LocationB\r\n2. LocationB: presented by FragmentB\r\n   * One text view to display the current count in number. Updated by event OnCounterUpdated\r\n   * Two buttons which increment and decrement count **continuously on hold**.\r\n   * Shares the result of counting updated by LocationB\r\n\r\nBelow is how to use AndroidMvc framework to implement and test the app including navigation. Note the code below doesn't show all code. To see more details check the sample project in the app - Simple under samples subfolder.\r\n\r\n##### 1. Extend MvcActivity for the single Activity\r\n````java\r\n/**\r\n * Single activity for the app\r\n */\r\npublic class MainActivity extends MvcActivity {\r\n    /**\r\n     * Define how to map navigation location id to full screen fragments\r\n     * @param locationId The location id in string\r\n     * @return The class of the fragment representing the navigation locations\r\n     */\r\n    @Override\r\n    protected Class<? extends MvcFragment> mapNavigationFragment(String locationId) {\r\n        switch (locationId) {\r\n            case \"LocationA\":\r\n                return FragmentA.class;\r\n            case \"LocationB\":\r\n                return FragmentB.class;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the delegate fragment for the activity\r\n     * @return\r\n     */\r\n    @Override\r\n    protected Class<? extends DelegateFragment> getDelegateFragmentClass() {\r\n        return ContainerFragment.class;\r\n    }\r\n\r\n    /**\r\n     * Container fragment extends DelegateFragment would be the root container fragments to swap\r\n     * full screen fragments inside it on navigation.\r\n     */\r\n    public static class ContainerFragment extends DelegateFragment {\r\n        /**\r\n         * What to do when app starts for the first time\r\n         */\r\n        @Override\r\n        protected void onStartUp() {\r\n            //Navigate to location a when app starts for the first time by navigation controller\r\n            //here we navigate to LocationA which result in load FragmentA mapped by the\r\n            //the method mapNavigationFragment above\r\n            getNavigationController().navigateTo(this, \"LocationA\");\r\n        }\r\n    }\r\n}\r\n````\r\n##### 2. Create FragmentA to present \"LocationA\"\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n    /**\r\n     * @return Layout id used to inflate the view of this MvcFragment.\r\n     */\r\n    @Override\r\n    protected int getLayoutResId() {\r\n        return R.layout.fragment_a;\r\n    }\r\n}\r\n````\r\n##### 3. Create a controller contract and the model it's managing\r\n````java\r\npackage com.shipdream.lib.android.mvc.samples.simple.controller;\r\n\r\n/**\r\n * Define controller contract and its events. And specify which model it manages by binding the\r\n * model type.\r\n */\r\npublic interface CounterController extends BaseController<CounterModel> {\r\n    /**\r\n     * Increment count and will raise {@link EventC2V.OnCounterUpdated}\r\n     * @param sender Who requests this action\r\n     */\r\n    void increment(Object sender);\r\n\r\n    /**\r\n     * Decrement count and will raise {@link EventC2V.OnCounterUpdated}\r\n     * @param sender Who requests this action\r\n     */\r\n    void decrement(Object sender);\r\n\r\n    /**\r\n     * Method to convert number to english\r\n     * @param number\r\n     * @return\r\n     */\r\n    String convertNumberToEnglish(int number);\r\n\r\n    /**\r\n     * Namespace the events for this controller by nested interface so that all its events would\r\n     * be referenced as CounterController.EventC2V.BlaBlaEvent\r\n     */\r\n    interface EventC2V {\r\n        /**\r\n         * Event to notify views counter has been updated\r\n         */\r\n        class OnCounterUpdated extends BaseEventC2V {\r\n            private final int count;\r\n            private final String countInEnglish;\r\n            public OnCounterUpdated(Object sender, int count, String countInEnglish) {\r\n                super(sender);\r\n                this.count = count;\r\n                this.countInEnglish = countInEnglish;\r\n            }\r\n\r\n            public int getCount() {\r\n                return count;\r\n            }\r\n\r\n            public String getCountInEnglish() {\r\n                return countInEnglish;\r\n            }\r\n        }\r\n    }\r\n}\r\n````\r\n##### 3. Implement the controller\r\n**Note that, to allow AndroidMvc to find the default implementation of injectable object, the implementation class must be under the sub-package \"internal\" which resides in the same parent package as the interface and the name must be [InterfaceName]Impl.** For this example, say CounterController is under package samples.simple.controller the  implementation must be named as CounterControllerImpl and placed under package samples.simple.controller.internal\r\n````java\r\n/**\r\n * Note the structure of the package name. It is in a subpackage(internal) sharing the same parent\r\n * package as the controller interface CounterController\r\n */\r\npackage com.shipdream.lib.android.mvc.samples.simple.controller.internal;\r\n\r\n/**\r\n * Note the class name is [CounterController]Impl.\r\n */\r\npublic class CounterControllerImpl extends BaseControllerImpl<CounterModel> implements CounterController{\r\n    /**\r\n     * Just return the class type of the model managed by this controller\r\n     * @return\r\n     */\r\n    @Override\r\n    protected Class<CounterModel> getModelClassType() {\r\n        return CounterModel.class;\r\n    }\r\n\r\n    @Override\r\n    public void increment(Object sender) {\r\n        int count = getModel().getCount();\r\n        getModel().setCount(++count);\r\n        //Post controller to view event to views\r\n        postC2VEvent(new EventC2V.OnCounterUpdated(sender, count, convertNumberToEnglish(count)));\r\n    }\r\n\r\n    @Override\r\n    public void decrement(Object sender) {\r\n        int count = getModel().getCount();\r\n        getModel().setCount(--count);\r\n        //Post controller to view event to views\r\n        postC2VEvent(new EventC2V.OnCounterUpdated(sender, count, convertNumberToEnglish(count)));\r\n    }\r\n\r\n    @Override\r\n    public String convertNumberToEnglish(int number) {\r\n        if (number < -3) {\r\n            return \"Less than negative three\";\r\n        } else  if (number == -3) {\r\n            return \"Negative three\";\r\n        } else  if (number == -2) {\r\n            return \"Negative two\";\r\n        } else  if (number == -1) {\r\n            return \"Negative one\";\r\n        } else if (number == 0) {\r\n            return \"Zero\";\r\n        } else if (number == 1) {\r\n            return \"One\";\r\n        } else if (number == 2) {\r\n            return \"Two\";\r\n        } else if (number == 3) {\r\n            return \"Three\";\r\n        } else {\r\n            return \"Greater than three\";\r\n        }\r\n    }\r\n}\r\n````\r\n\r\n##### 4. Inject Controller into Views, setup views and handle C2V events from controllers\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n\t@Inject\r\n    private CounterController counterController;\r\n\r\n    private TextView display;\r\n    private Button increment;\r\n    private Button decrement;\r\n\r\n    /**\r\n     * @return Layout id used to inflate the view of this MvcFragment.\r\n     */\r\n    @Override\r\n    protected int getLayoutResId() {\r\n        return R.layout.fragment_a;\r\n    }\r\n\r\n    /**\r\n     * Lifecycle similar to onViewCreated by with more granular control with an extra argument to\r\n     * indicate why this view is created: 1. first time created, or 2. rotated or 3. restored\r\n     * @param view The root view of the fragment\r\n     * @param savedInstanceState The savedInstanceState when the fragment is being recreated after\r\n     *                           its enclosing activity is killed by OS, otherwise null including on\r\n     *                           rotation\r\n     * @param reason Indicates the {@link Reason} why the onViewReady is called.\r\n     */\r\n    @Override\r\n    public void onViewReady(View view, Bundle savedInstanceState, Reason reason) {\r\n        super.onViewReady(view, savedInstanceState, reason);\r\n\r\n        display = (TextView) view.findViewById(R.id.fragment_a_counterDisplay);\r\n        increment = (Button) view.findViewById(R.id.fragment_a_buttonIncrement);\r\n        decrement = (Button) view.findViewById(R.id.fragment_a_buttonDecrement);\r\n\r\n        increment.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                counterController.increment(v);\r\n            }\r\n        });\r\n\r\n        decrement.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                counterController.decrement(v);\r\n            }\r\n        });\r\n\r\n        updateCountDisplay(counterController.getModel().getCount());\r\n    }\r\n\r\n    /**\r\n     * Callback when the fragment is popped out by back navigation\r\n     */\r\n    @Override\r\n    protected void onPoppedOutToFront() {\r\n        super.onPoppedOutToFront();\r\n        updateCountDisplay(counterController.getModel().getCount());\r\n    }\r\n\r\n    //Define event handler by method named as onEvent with single parameter of the event type\r\n    //to respond event CounterController.EventC2V.OnCounterUpdated\r\n    private void onEvent(CounterController.EventC2V.OnCounterUpdated event) {\r\n        updateCountDisplay(event.getCount());\r\n    }\r\n\r\n    /**\r\n     * Update the text view of count number\r\n     * @param count The number of count\r\n     */\r\n    private void updateCountDisplay(int count) {\r\n        display.setText(String.valueOf(count));\r\n    }\r\n}\r\n````\r\n##### 5. Unit tests on controllers\r\nAs discussed before, business logic should be decoupled from view(Android components) and abstracted to controllers, then we can pretty much test most logic just on controllers without dependencies of any Android components. Views just need to make sure data carried back from controllers are displayed correctly. Whether or not the data is processed correctly is completely controllers' responsibilities that is what is being tested here.\r\n\r\n````java\r\npublic class TestCounterController {\r\n\t...other dependencies are omitted here\r\n\r\n    private CounterController counterController;\r\n\r\n    @Before\r\n    public void setUp() throws Exception {\r\n    \t...other dependencies are omitted here\r\n\r\n        //create instance of CounterController\r\n        counterController = new CounterControllerImpl();\r\n        counterController.init();\r\n    }\r\n\r\n    @Test\r\n    public void increment_should_post_counter_update_event_with_incremented_value() {\r\n        //1. Prepare\r\n        //prepare event monitor\r\n        class Monitor {\r\n            void onEvent(CounterController.EventC2V.OnCounterUpdated event) {\r\n            }\r\n        }\r\n        Monitor monitor = mock(Monitor.class);\r\n        eventBusC2V.register(monitor);\r\n\r\n        //mock controller model for count value\r\n        int value = new Random().nextInt();\r\n        CounterModel counterModel = mock(CounterModel.class);\r\n        when(counterModel.getCount()).thenReturn(value);\r\n        //Bind the mock model to the controller\r\n        counterController.bindModel(this, counterModel);\r\n\r\n        //2. Act\r\n        counterController.increment(this);\r\n\r\n        //3. Verify\r\n        ArgumentCaptor<CounterController.EventC2V.OnCounterUpdated> updateEvent\r\n                = ArgumentCaptor.forClass(CounterController.EventC2V.OnCounterUpdated.class);\r\n        //event should be fired once\r\n        verify(monitor, times(1)).onEvent(updateEvent.capture());\r\n        //event should carry incremented value\r\n        Assert.assertEquals(value + 1, updateEvent.getValue().getCount());\r\n    }\r\n}\r\n````\r\n##### 5. Navigation\r\nInstead creating, replacing or popping full screen fragments by FragmentManager of Android Activity, AndroidMvc provides NavigationController to manage navigation. Therefore, navigation logic can be abstracted out from View layer. To make navigation easier to be tested, we can inject NavigationController to CounterController and then test the model of NavigationController to verify if navigation location is changed as expected.\r\n##### 5.1. Add two methods to CounterController to wrap navigation logic\r\n````java\r\npublic interface CounterController extends BaseController<CounterModel> {\r\n\t... other methods\r\n\r\n\t/**\r\n     * Navigate to LocationB by {@link NavigationController}to show advance view that can update\r\n     * count continuously by holding buttons.\r\n     * @param sender\r\n     */\r\n    void goToAdvancedView(Object sender);\r\n\r\n    /**\r\n     * Navigate back to LocationA by {@link NavigationController}to show basic view from LocationB\r\n     * @param sender\r\n     */\r\n    void goBackToBasicView(Object sender);\r\n\r\n\t... other methods\r\n}\r\n````\r\n##### 5.2. Inject NavigationController to CounterControllerImpl and implement navigation methods\r\n````java\r\npublic class CounterControllerImpl extends BaseControllerImpl<CounterModel> implements CounterController{\r\n\t... other methods\r\n\r\n    @Inject\r\n    NavigationController navigationController;\r\n\r\n    @Override\r\n    public void goToAdvancedView(Object sender) {\r\n        navigationController.navigateTo(sender, \"LocationB\");\r\n    }\r\n\r\n    @Override\r\n    public void goBackToBasicView(Object sender) {\r\n        navigationController.navigateBack(sender);\r\n    }\r\n\r\n    ... other methods\r\n}\r\n````\r\n##### 5.3. Invoke CounterController methods wrapping navigation in views\r\n````java\r\npublic class FragmentA extends MvcFragment {\r\n\t...\r\n\r\n    @Override\r\n    public void onViewReady(View view, Bundle savedInstanceState, Reason reason) {\r\n        super.onViewReady(view, savedInstanceState, reason);\r\n\r\n        ...\r\n\r\n        buttonShowAdvancedView.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                //Use counterController to manage navigation to make navigation testable\r\n                counterController.goToAdvancedView(v);\r\n                //Or we can use NavigationController directly though it's harder to unit test on\r\n                //controller level.\r\n                //example:\r\n                //navigationController.navigateTo(v, \"LocationB\");\r\n            }\r\n        });\r\n\r\n        ...\r\n    }\r\n\r\n    ...\r\n}\r\n\r\npublic class FragmentB extends MvcFragment {\r\n\t...\r\n\r\n    @Override\r\n    public boolean onBackButtonPressed() {\r\n        //Use counterController to manage navigation back make navigation testable\r\n        counterController.goBackToBasicView(this);\r\n        //Return true to not pass the back button pressed event to upper level handler.\r\n        return true;\r\n        //Or we can let the fragment manage back navigation back automatically where we don't\r\n        //override this method which will call NavigationController.navigateBack(Object sender)\r\n        //automatically\r\n    }\r\n\r\n    ...\r\n}\r\n````\r\n##### 5.4. Able to test navigation on CounterController\r\n````java\r\n    @Test\r\n    public void should_navigate_to_locationB_when_go_to_advance_view_and_back_to_locationA_after_go_to_basic_view() {\r\n        //Prepare\r\n        NavigationController navigationController = ((CounterControllerImpl) counterController).navigationController;\r\n        NavigationController.Model navModel = navigationController.getModel();\r\n        //App has not navigated to anywhere, current location should be null\r\n        Assert.assertNull(navModel.getCurrentLocation());\r\n        //Simulate navigating to location A\r\n        navigationController.navigateTo(this, \"LocationA\");\r\n        //Verify: location should be changed to LocationA\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationA\");\r\n\r\n        //Act: CounterController now goes to advanced view underlining logic is navigating to locationB\r\n        counterController.goToAdvancedView(this);\r\n\r\n        //Verify: Current location should be LocationB\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationB\");\r\n\r\n        //Act: CounterController now goes back to basic view underlining logic is navigating back to locationA\r\n        counterController.goBackToBasicView(this);\r\n\r\n        //Verify: Current location should be back to LocationA\r\n        Assert.assertEquals(navModel.getCurrentLocation().getLocationId(), \"LocationA\");\r\n    }\r\n````\r\n\r\n## Other features\r\n#### 1. Dependency Injection\r\n\r\n##### @Inject\r\n\r\nThe framework currently only support field injection. To inject an object, use @Inject to annotate fields and then inject the object with those fields by\r\n````java\r\nAndroidMvc.graph().inject(ObjectToBeInjected)\r\n````\r\nAll injected objects will be reference counted. This is because\r\nthe graph will automatically save and restore injected objects implementing StateManaged. For performance reasons the injected but not anymore referenced objects don't need to be saved and restored. So don't forget to call\r\n````java\r\nAndroidMvc.graph().release(ObjectBeenInjected)\r\n````\r\nto dereference them. Fortunately, all MvcFragment will do the injection and releasing in their\r\nAndroid lifecycle - onCreate and onDestroy. So we don't need to do this manually for fragments.\r\n\r\n**But why do we release? Isn't Java managing garbage collection automatically?\r\n\r\nYes java does it. But since all controllers of AndroidMvc are singleton to assure the single source of truth, if there are used by multiple consumers, the shared instance of the controller will be held by a cache. And the model of the controller will be automatically saved and restored on demand of recreation and destroy of fragments. So if a controller is not used anymore, we can dereference the controller. Then AndroidMvc will stop managing its model.\r\n\r\nIn addition, instances of fragments in their back stack will be held by OS until they are killed. This holds up a lot memory if the back stack is deep. Since those fragments are not visible, there is no point to hold the data they are referencing any longer. To release reference of controllers will help AndroidMvc be aware which controllers are not used anymore, thereafter AndroidMvc can free up the memory holding their models. What about if those fragments want to resume by popping out from the back stack? As mentioned before, AndroidMvc will restore the state/model of the controllers the fragments reference which are saved when the fragments are pushed into the back stack.**\r\n\r\n#### [More details about dependency injection with Poke, see its documentation here](https://github.com/kejunxia/AndroidMvc/tree/master/library/poke)\r\n\r\n\r\n### 2. Unit testing on asynchronous actions, e.g. Http requests\r\nBelow is an example to consume a public weather API from [OpenWeatherMap](http://openweathermap.org/api). To be able to test controller without real http communication, the http request can be abstracted into a service interface. The service interface is injected into controllers. Then in real implementation of the service interface we send http request by http client while in controller testings we mock the service to provide mock data.\r\n\r\nSee more details in the sample project - Node\r\n\r\n**Note that, BaseMvcControllerImpl provides protected methods to run actions asynchronously. The ExecutorService is injected into controllers. By default, AndroidMvc framework automatically injects with an implementation running tasks on non-main thread. Whereas in unit tests we can override the injection with an implementation runs the task on the same thread as the caller's so that the asynchronous actions can be tested easier.**\r\n````java\r\n/**\r\n * Run async task on the default ExecutorService injected as a field of this class. Exceptions\r\n * occur during running the task will be handled by the given {@link AsyncExceptionHandler}.\r\n *\r\n * @param sender                who initiated this task\r\n * @param asyncTask             task to execute\r\n * @param asyncExceptionHandler error handler for the exception during running the task\r\n * @return the reference of {@link AsyncTask} that can be used to query its state and cancel it.\r\n */\r\nprotected AsyncTask runAsyncTask(Object sender, AsyncTask asyncTask, AsyncExceptionHandler asyncExceptionHandler)\r\n````\r\n\r\n##### 1. Define http service interface\r\n````java\r\npackage com.shipdream.lib.android.mvc.samples.note.service.http;\r\n\r\npublic interface WeatherService {\r\n    /**\r\n     * Get weathers of the cities with the given ids\r\n     * @param ids Ids of the cities\r\n     * @return The response\r\n     */\r\n    WeatherListResponse getWeathers(List<Integer>ids) throws IOException;\r\n}\r\n````\r\n##### 2. Send and consume real http service in implementation\r\n````java\r\n/**\r\n * Note the package structure which is under internal subpackage sharing the same parent package as\r\n * WeatherService as above\r\n */\r\npackage com.shipdream.lib.android.mvc.samples.note.service.http.internal;\r\n\r\npublic class WeatherServiceImpl implements WeatherService{\r\n    private HttpClient httpClient;\r\n    private Gson gson;\r\n\r\n    public WeatherServiceImpl() {\r\n        httpClient = new DefaultHttpClient();\r\n        gson = new Gson();\r\n    }\r\n\r\n    @Override\r\n    public WeatherListResponse getWeathers(List<Integer> ids) throws IOException {\r\n        String idsStr = \"\";\r\n        for (Integer id : ids) {\r\n            if (!idsStr.isEmpty()) {\r\n                idsStr += \", \";\r\n            }\r\n            idsStr += String.valueOf(id);\r\n        }\r\n        String url = String.format(\"http://api.openweathermap.org/data/2.5/group?id=%s&units=metric\",\r\n                URLEncoder.encode(idsStr, \"UTF-8\"));\r\n        HttpGet get = new HttpGet(url);\r\n        HttpResponse resp = httpClient.execute(get);\r\n        String responseStr = EntityUtils.toString(resp.getEntity());\r\n        return gson.fromJson(responseStr, WeatherListResponse.class);\r\n    }\r\n}\r\n````\r\n##### 3. Inject the http service into WeatherControllerImpl\r\n````java\r\npublic class WeatherControllerImpl extends BaseControllerImpl <WeatherModel> implements\r\n        WeatherController{\r\n\t....\r\n\r\n    @Inject\r\n    private WeatherService weatherService;\r\n\r\n    //consume the service and fetch weathers\r\n    //...\r\n}\r\n````\r\n##### 4. In controller unit test, override injection of ExecutorService with implementation running actions on the same thread as the caller's\r\nCode below is partial implementation, see sample Note in the project for more details.\r\n````java\r\npublic class TestWeatherController extends TestControllerBase<WeatherController> {\r\n@Override\r\nprotected void registerDependencies(MvcGraph mvcGraph) {\r\n\t...\r\n\r\n\t//Setup mock executor service mock that runs task on the same thread.\r\n\texecutorService = mock(ExecutorService.class);\r\n\tdoAnswer(new Answer() {\r\n\t\t@Override\r\n\t\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\r\n\t\t\tRunnable runnable = (Runnable) invocation.getArguments()[0];\r\n\t\t\trunnable.run();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}).when(executorService).submit(any(Runnable.class));\r\n\r\n    //Register the injecting component to mvcGraph to override the implementation being injected\r\n    //to controllers\r\n\tTestComp testComp = new TestComp();\r\n\ttestComp.testNoteController = this;\r\n\tmvcGraph.register(testComp);\r\n}\r\n}\r\n````\r\n\r\n##### 5. Test if WeatherController sends successful event with good http response\r\nWhat to mock\r\n1. Http Service to provide good response\r\n2. Event monitor to subscribe to the successful event\r\nSo when WeatherController#updateAllCities(Object) is called, we can verify whether the mocked monitor receives the successful event.\r\n\r\n````java\r\n@Test\r\npublic void shouldRaiseSuccessEventForGoodUpdateWeathers() throws IOException {\r\n\t//---Arrange---\r\n\t//Define a subscriber class\r\n\tclass Monitor {\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdated event) {\r\n\t\t}\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdateFailed event) {\r\n\t\t}\r\n\t}\r\n\tMonitor monitor = mock(Monitor.class);\r\n    //Subscribe to eventBus\r\n\teventBusC2V.register(monitor);\r\n\r\n    //Weather service mock prepares a good response\r\n\tWeatherListResponse responseMock = mock(WeatherListResponse.class);\r\n\twhen(weatherServiceMock.getWeathers(any(List.class))).thenReturn(responseMock);\r\n\r\n\t//---Action---\r\n\tcontrollerToTest.updateAllCities(this);\r\n\r\n\t//---Verify---\r\n\t//Success event should be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdated> eventSuccess\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdated.class);\r\n\tverify(monitor, times(1)).onEvent(eventSuccess.capture());\r\n\t//Failed event should not be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdateFailed> eventFailure\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdateFailed.class);\r\n\tverify(monitor, times(0)).onEvent(eventFailure.capture());\r\n}\r\n````\r\n\r\n##### 6. **Test if WeatherController sends failed event with bad http response**\r\nWhat to mock\r\n1. Http Service to provide bad response\r\n2. Event monitor to subscribe to the failed event\r\nSo when WeatherController#updateAllCities(Object) is called, we can verify whether the mocked monitor receives the failed event.\r\n````java\r\n@Test\r\npublic void shouldRaiseFailEventForNetworkErrorToUpdateWeathers() throws IOException {\r\n\t//---Arrange---\r\n\t//Define a subscriber class\r\n\tclass Monitor {\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdated event) {\r\n\t\t}\r\n\t\tpublic void onEvent(WeatherController.EventC2V.OnWeathersUpdateFailed event) {\r\n\t\t}\r\n\t}\r\n\tMonitor monitor = mock(Monitor.class);\r\n    //Subscribe to eventBus\r\n\teventBusC2V.register(monitor);\r\n\r\n\t//Weather service mock prepares a bad response\r\n    //by throwing an exception when getting the weather data\r\n\twhen(weatherServiceMock.getWeathers(any(List.class))).thenThrow(new IOException());\r\n\r\n\t//---Action---\r\n\tcontrollerToTest.updateAllCities(this);\r\n\r\n\t//---Verify---\r\n\t//Success event should not be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdated> eventSuccess\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdated.class);\r\n\tverify(monitor, times(0)).onEvent(eventSuccess.capture());\r\n\t//Failed event must be raised\r\n\tArgumentCaptor<WeatherController.EventC2V.OnWeathersUpdateFailed> eventFailure\r\n\t\t\t= ArgumentCaptor.forClass(WeatherController.EventC2V.OnWeathersUpdateFailed.class);\r\n\tverify(monitor, times(1)).onEvent(eventFailure.capture());\r\n}\r\n````\r\n\r\n### 3. Custom mechanism to automatically save/restore models of controllers\r\nBy default, AndroidMvc uses GSON to serialize and deserialize models of controllers automatically. In general uses the performance is acceptable. For example, on rotation, as long as the models are not very large, the frozen time of the rotation would be between 200ms and 300ms.\r\n\r\nIf we need to provide more optimized mechanism to do so in case there are large models taking long to be serialized and deserialized by GSON, custom StateKeeper can be set to provide alternative save/restore implementation. For Android, Parcelable is the best performed mechanism to save/restore state but it is not fun and error prone. Fortunately, there a handy library [Parceler](https://github.com/johncarl81/parceler) from another developer does this automatically. In the example below, we tried this library to implement custom StateKeeper to save/restore state by Parcelables automatically. The best place to set the custom StateKeeper is the Application#onCreate().\r\n\r\nCheck out more details in the sample code - Note\r\n\r\n````java\r\npublic class NoteApp extends Application {\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n\r\n        AndroidMvc.setCustomStateKeeper(new AndroidStateKeeper() {\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public Parcelable saveState(Object state, Class type) {\r\n                /**\r\n                 * Use parcelable to save all states.\r\n                 */\r\n                return Parcels.wrap(state);\r\n                //type of the state can be used as a filter to handle some state specially\r\n                //if (type == BlaBlaType) {\r\n                //    special logic to save state\r\n                //}\r\n            }\r\n\r\n            @SuppressWarnings(\"unchecked\")\r\n            @Override\r\n            public Object getState(Parcelable parceledState, Class type) {\r\n                /**\r\n                 * Use parcelable to restore all states.\r\n                 */\r\n                return Parcels.unwrap(parceledState);\r\n\r\n                //type of the state can be used as a filter to handle some state specially\r\n                //if (type == BlaBlaType) {\r\n                //    special logic to restore state\r\n                //}\r\n            }\r\n        });\r\n    }\r\n}\r\n````","google":"UA-21820164-19","note":"Don't delete this file! It's used internally to help with page regeneration."}